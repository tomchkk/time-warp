#!/usr/bin/env bash

__watch_feature_options_resolver=${1:?"An options resolver is required"}
__watch_feature_consumer=${2:?"A consumer is required"}
__watch_feature_bus=${3:?"A message bus is required"}
__watch_feature_logger=${4:?"A logger is required"}
__watch_feature_debug=${5:-false}

source $__watch_feature_logger

##
# Feature exit strategy
##
__watch_feature::on_exit() {
    source $__watch_feature_bus
    message_bus::dispatch_message "KILL"
}

##
# Initiates a watch of a given path or paths for modifications.
##
feature::watch() {
    local profiles="${1:?"A profile file or directory is required"}"
    local root_paths="${@:2}"

    source $__watch_feature_options_resolver

    local filters=$(options_resolver::resolve_filters "$profiles")
    local watches=$(options_resolver::resolve_watches "$root_paths")

    if [[ -z $filters ]] || [[ -z $watches ]]; then
        exit 1
    fi

    trap __watch_feature::on_exit SIGINT

    source $__watch_feature_consumer && consumer::consume &

    local resolved=(
        ${watches[*]}
        ${filters[*]}
        # $($__watch_feature_debug && echo "--verbose")
        --postpone
        -- time-warp queue --produce $profiles
    )

    log::debug "Resolved watchexec options: ${resolved[*]}"
    log::debug "Launching watchexec with pid: $$"

    watchexec ${resolved[*]}
}
