#!/usr/bin/env bash

# opens a fifo pipe at the given path and then executes the given command using
# arguments pushed to the pipe, or echos the arguments, if no command is given

__consumer_fifo="${1:?"A fifo pipe path is required"}"
__consumer_logger="${2:?"A logger is required"}"
__consumer_message_handler="${3:?"A message handler is required"}"

source $__consumer_logger
source $__consumer_message_handler

##
# Performs actions on exit of the consumer
##
__consumer::exit() {
    rm -f $__consumer_fifo
    log::info "Queue consumer exited"
}

##
# Start the consumer
##
consumer::consume() {
    # TODO:
    # - record the number of messages processed (and each type?) "throughput"

    # make the pipe if it doesn't exist already
    [[ -e "$__consumer_fifo" ]] || mkfifo "$__consumer_fifo"

    # remove the pipe on exit
    trap __consumer::exit EXIT

    # record the time the process came up
    local start_time=$(date +"%s")

    log::info "Queue consumer started"

    local message=""

    while true; do
        if read -r message < $__consumer_fifo; then
            local timestamp=$(date +"%s")

            log::info "Message received: $message"

            local context=(
                --pipe="$__consumer_fifo"
                --queue-pid="$$"
                --timestamp="$timestamp"
                --uptime="$(($timestamp - $start_time))"
            )

            message_handler::handle_message $message "${context[*]}"
        fi
    done
}
