#!/usr/bin/env bash

# opens a fifo pipe at the given path and then executes the given command using
# arguments pushed to the pipe, or echos the arguments, if no command is given

# construct the script's dependencies
{
    __parameters=(
        __consumer_fifo=@excluding-pipe
        @stdout-logger
        @message-handler
    )
    source "$SERVICE_LOADER" "$BASH_SOURCE" ${__parameters[*]}
    unset __parameters
}

if [[ -z "$__consumer_fifo" ]]; then
    log_slog::error "A fifo pipe path must be provided" && exit 1
fi

# make the pipe if it doesn't exist already
[[ -e "$__consumer_fifo" ]] || mkfifo "$__consumer_fifo"

# remove the pipe on exit
trap "rm -f $__consumer_fifo" EXIT

# record the time the process came up
__consumer_start_time=$(date +"%s")

while true; do
    # TODO: can we do a while read?
    if read -r __consumer_message < $__consumer_fifo; then
        __consumer_timestamp=$(date +"%s")

        # TODO: add event dispatcher?

        log_slog::info "Message received: $__consumer_message"

        __consumer_context=(
            --pipe="$__consumer_fifo"
            --queue-pid="$$"
            --timestamp="$__consumer_timestamp"
            --uptime="$(($__consumer_timestamp - $__consumer_start_time))"
        )

        message_handler::handle_message $__consumer_message \
            "${__consumer_context[*]}"
    fi
done
