#!/usr/bin/env bash

# opens a fifo pipe at the given path and then executes the given command using
# arguments pushed to the pipe, or echos the arguments, if no command is given

__consumer_logger="${1:?"A logger is required"}" && source $__consumer_logger
__consumer_fifo="${2:?"A fifo pipe path is required"}"
__consumer_message_handler="${3:?"A message handler is required"}" \
    && source $__consumer_message_handler


# make the pipe if it doesn't exist already
[[ -e "$__consumer_fifo" ]] || mkfifo "$__consumer_fifo"

##
# Performs actions on exit of the consumer
##
__consumer::exit() {
    rm -f $__consumer_fifo
    log_slog::info "Queue consumer exited"
}

# remove the pipe on exit
trap __consumer::exit EXIT

# record the time the process came up
__consumer_start_time=$(date +"%s")

log_slog::info "Queue consumer started"

while true; do
    if read -r __consumer_message < $__consumer_fifo; then
        __consumer_timestamp=$(date +"%s")

        log_slog::info "Message received: $__consumer_message"

        __consumer_context=(
            --pipe="$__consumer_fifo"
            --queue-pid="$$"
            --timestamp="$__consumer_timestamp"
            --uptime="$(($__consumer_timestamp - $__consumer_start_time))"
        )

        message_handler::handle_message $__consumer_message \
            "${__consumer_context[*]}"
    fi
done
