#!/usr/bin/env bash

# opens a fifo pipe at the given path and then executes the given command using
# arguments pushed to the pipe, or echos the arguments, if no command is given

__consumer_fifo="${1:?"A fifo pipe path is required"}"
__consumer_logger="${2:?"A logger is required"}"
__consumer_message_handler="${3:?"A message handler is required"}"

source $__consumer_logger

##
# Performs actions on exit of the consumer
##
__consumer::exit() {
    rm -f $__consumer_fifo

    log::info "Queue consumer exited"
}

##
# Start the consumer
##
consumer::consume() {
    # make the pipe if it doesn't exist already
    [[ -e "$__consumer_fifo" ]] || mkfifo "$__consumer_fifo"

    # remove the pipe on exit
    trap __consumer::exit EXIT

    source $__consumer_message_handler

    # record the time the process came up
    local start_time=$(date +"%s")
    local message_count=0
    local message=""

    log::info "Queue consumer started"

    while true; do
        if read -r message < $__consumer_fifo; then
            local timestamp=$(date +"%s")
            local uptime=$(($timestamp - $start_time))
            local context=(
                --pipe="$__consumer_fifo"
                --queue-pid=$$
                --timestamp=$timestamp
                --uptime=$uptime
                --message-count=$((++message_count))
            )

            log::debug "Message received: $message" ${context[*]}

            message_handler::handle_message $message "${context[*]}"
        fi
    done
}
