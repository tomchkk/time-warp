#!/usr/bin/env bash

__command_usage() {
    cat << EOF
$app_name ($version) - Queue

Consume or produce $app_name queue items.

Usage:  $app_name queue [options] <args>

Options:
    -h, --help      Print usage information
    -c, --consume   Open a FIFO pipe to consume items pushed to the queue
    -k, --kill      Kill running queue services
    -l, --list      List running queue services
    -p, --produce   Produce queue items

EOF
}

pipe=$(__container_get "excluding-pipe")
bus=$(__container_get "message-bus")

opt="$1" && shift
args="$@"

case "$opt" in
    -c|--consume)
        source $(__container_get "excluding-consumer")
    ;;
    -k|--kill)
        if [[ -e "$pipe" ]]; then
            source $bus && __dispatch_message "kill"
            echo "The queue at '$pipe' has been killed."
        else
            echo "Only an open queue can be killed!"
        fi
    ;;
    -l|--list)
        echo "list running queue services..."
    ;;
    -r|--report)
        if [[ -e "$pipe" ]]; then
            source $bus && __dispatch_message "report"
        else
            echo "Only an open queue can issue a report!"
        fi

        # if [[ -p "$pipe" ]]; then
        #     echo "report --target=$(tty) --foo" > $pipe
        # else
        #     echo "No queues open to report"
        # fi




        # target=$(echo "$args" | grep -oE '/dev/ttys\d+')
        # echo -e "\nreporting $args" &>$target

        # FIFO="$queue/$reporting_fifo"
        # trap "rm -f $FIFO" EXIT

        # if [ ! -e "$FIFO" ]; then
        #     mkfifo "$FIFO"
        # fi

        # # for report in $args; do
        #     echo $args > $FIFO &
        # # done

        # while read -r report; do
        #     target=$(echo "$report" | grep -oE '/dev/ttys\d+')
        #     echo "reporting $report" &>$target
        # done < $FIFO
    ;;
    -p|--produce)
        # - runs `watchexec --resolved-options -- /path/2/producer`
        #   - watches for changes to given paths gets filters from profiles
        #   - ignores changes caused by itself
        #   - passes normalised path to `time-warp match $path` to match the path to a
        #     configured profile
        #   - on successful match, pushes message (timestamp and path) to time-warp/excluding.q file

        # watchexec \
        #     --watch /Users/tom/ \
        #     --filter '**/vendor' \
        #     --ignore '**/vendor/**/vendor/**' \
        #     --no-vcs-ignore \
        #     --no-default-ignore \
        #     --no-shell \
        #     -- "$service/queue/producer"
    ;;
    -h|--help|*)
        __command_usage && exit 0
    ;;
esac
