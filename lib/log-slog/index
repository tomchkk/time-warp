#!/usr/bin/env bash

__log_slog_max_level="$1"
__log_slog_channel="$2"

if [[ -z "$__log_slog_max_level" ]] || [[ ! -w "$__log_slog_channel" ]]; then
    echo "Error: both 'max level' and 'channel' parameters are required."
    exit 1
fi

##
# Gets the numerical value for a log level
##
__log_slog::get_level_value() {
    local level="$1"
    local levels=(
        "EMERGENCY" "ALERT" "CRITICAL" "ERROR" "WARNING" "NOTICE" "INFO" "DEBUG"
    )

    for i in ${!levels[*]}; do
        if [[ "$level" == "${levels[$i]}" ]]; then
            echo "$i" && break
        fi
    done
}

##
# Determines if, given a set maximum allowable level, the given level has been
# reached.
##
__log_slog::level_reached() {
    local level="$1"

    local required="$(__log_slog::get_level_value $level)"
    local max="$(__log_slog::get_level_value $__log_slog_max_level)"

    [[ $required -le $max ]] && echo true || echo false
}

##
# Attempt to log a message.
#
log_slog::log() {
    local level="$1"
    local message="$2"
    local context="$3"

    local prefix=" ->"
    local timestamp="[$(date +"%Y-%m-%d %H:%M:%S")]"
    local separator="-"

    if $(__log_slog::level_reached $level); then
        echo "$prefix $timestamp $level $separator $message $context" > $__log_slog_channel
    fi
}

##
# Proxy methods for the main log_slog::log method
##

log_slog::emergency() {
    log_slog::log "EMERGENCY" "$1" "$2"
}
log_slog::alert() {
    log_slog::log "ALERT" "$1" "$2"
}
log_slog::critical() {
    log_slog::log "CRITICAL" "$1" "$2"
}
log_slog::error() {
    log_slog::log "ERROR" "$1" "$2"
}
log_slog::warning() {
    log_slog::log "WARNING" "$1" "$2"
}
log_slog::notice() {
    log_slog::log "NOTICE" "$1" "$2"
}
log_slog::info() {
    log_slog::log "INFO" "$1" "$2"
}
log_slog::debug() {
    log_slog::log "DEBUG" "$1" "$2"
}
